<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zusammenfassung: PHP REST API Entwicklung</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
            color: #333;
        }
        .container {
            max-width: 1000px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #4a4a8f; /* PHP-Farbe */
            border-bottom: 3px solid #e0e0e0;
            padding-bottom: 10px;
        }
        h2 {
            color: #383870;
            margin-top: 30px;
            border-bottom: 1px dashed #ccc;
            padding-bottom: 5px;
        }
        h3 {
            color: #555;
            margin-top: 20px;
        }
        pre {
            background: #272822; /* Monokai-ähnlich */
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.9em;
            word-wrap: normal;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #e9e9e9;
        }
        ul {
            padding-left: 20px;
        }
        strong {
            color: #383870;
        }
        .note {
            background-color: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 10px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gesprächszusammenfassung: Entwicklung einer PHP REST API</h1>

        <h2>1. Basis-PHP REST API (api.php)</h2>
        <p>Die rudimentäre API mit den Endpunkten <code>isAlive</code>, <code>version</code> und <code>help</code>, implementiert ohne Frameworks:</p>
        <pre>&lt;?php

// 1. Header setzen: Antwort ist JSON
header('Content-Type: application/json');

// 2. Service-Informationen
$service_version = "1.0.0";
$api_name = "Basic Utility API";

// ... (Pfad-Analyse und Dispatcher-Logik, die später optimiert wurde) ...

// 4. Funktions-Implementierung (Auszug)
switch ($endpoint) {
    case 'isAlive':
        $response = [
            'status' => 'OK',
            'message' => 'Service is up and running.',
            'timestamp' => date('Y-m-d H:i:s')
        ];
        http_response_code(200);
        break;
    
    // ... (Weitere Endpunkte) ...
    
    default:
        $response = ['status' => 'Error', 'message' => "Endpoint '{$endpoint}' not found.", 'error_code' => 404];
        http_response_code(404);
        break;
}

echo json_encode($response, JSON_PRETTY_PRINT);
if (!class_exists('PHPUnit\Framework\TestCase', false)) {
    exit;
}

?&gt;</pre>

        <h2>2. Clean URLs und Versionierung (/api/v1/)</h2>
        <p>Um die URL-Struktur zu verbessern, wurde <code>mod_rewrite</code> in Apache verwendet.</p>

        <h3>.htaccess Datei (für /api/v1/ Endpunkte)</h3>
        <pre># Aktiviere das Rewrite-Modul
RewriteEngine On

# Überspringe, wenn die Datei oder das Verzeichnis existiert
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d

# Leite /api/v1/isAlive intern an api.php/v1/isAlive weiter
RewriteRule ^api/([vV][0-9]+)/(.*)$ api.php/$1/$2 [L]</pre>

        <h2>3. PHPUnit Testing und Data Providers</h2>
        <p>Zum Testen der API wurde eine PHPUnit-Klasse erstellt, welche die HTTP-Umgebung simuliert und Data Providers für effizientes Testen verwendet.</p>

        <h3>Data Provider Muster (Auszug aus ApiTest.php)</h3>
        <pre>&lt;?php declare(strict_types=1);

// ... (Imports und setUp/callApi Methoden) ...

final class ApiTest extends TestCase
{
    // ...

    public static function apiEndpointsDataProvider(): array
    {
        return [
            'isAlive V1' => ['v1', 'isAlive', 200, 'timestamp'],
            'Version V1' => ['v1', 'version', 200, 'service_implementation_version'],
            'Unsupported Version V99' => ['v99', 'isAlive', 400, 'supported_versions'],
        ];
    }
    
    /**
     * @dataProvider apiEndpointsDataProvider
     */
    public function testApiEndpoints(
        string $version, 
        string $endpoint, 
        int $expectedStatus,
        string $expectedKey
    ): void
    {
        $this->callApi($version, $endpoint);
        $message = "Endpunkt /api/{$version}/{$endpoint} sollte Status {$expectedStatus} zurückgeben.";
        $this->assertSame($expectedStatus, $this->response['status'], $message);
        $this->assertArrayHasKey($expectedKey, $this->response['data']);
    }
}</pre>
        
        <h2>4. Architektur: MVC-Ähnliche Struktur (Controller-Service-Repository)</h2>
        <p>Wir haben besprochen, dass APIs eine geschichtete Architektur nutzen sollten, um Zuständigkeiten zu trennen:</p>
        <ul>
            <li><strong>Controller:</strong> Nimmt HTTP-Anfragen entgegen, validiert Eingaben, wählt Service.</li>
            <li><strong>Service:</strong> Enthält die Geschäftslogik und koordiniert Aktionen.</li>
            <li><strong>Repository/Model:</strong> Stellt den Datenzugriff (z.B. Datenbank) bereit.</li>
        </ul>

        <h2>5. Client-Entwicklung: Sicherer PHP-Client als Middleware</h2>
        <p>Aufgrund von Sicherheitsbedenken (Sichtbarkeit von Geheimnissen) wurde ein unsichtbarer **PHP-Client (Middleware)** entworfen, der die API Server-zu-Server konsumiert.</p>

        <h3>PHP Client (client.php)</h3>
        <pre>&lt;?php

// 1. KONFIGURATION (Geheimnisse bleiben unsichtbar)
const API_BASE_URL = 'http://localhost/api/v1'; 
// const API_SECRET_KEY = 'Ihr_Geheimer_Schlüssel_12345'; // Hier speichern!

// ... (callApi-Funktion mit cURL) ...

// 3. ANWENDUNG / ROUTING
$requestedEndpoint = $_GET['action'] ?? 'help';

// Ruft die API über cURL auf
$result = callApi($requestedEndpoint);

// 4. Antwort formatieren und an den Browser senden
header('Content-Type: application/json');
http_response_code($result['status']);
echo json_encode($result['data'], JSON_PRETTY_PRINT);
exit;
?&gt;</pre>
        
        <h3>JavaScript Client (app.js) - Aufruf der Middleware</h3>
        <p>Der Frontend-Client ruft nun <code>client.php?action=...</code> auf, nicht mehr die API direkt.</p>
        <pre>// app.js Auszug
function callEndpoint(endpoint) {
    // ... (Initialisierung) ...
    
    // Die URL zeigt auf den PHP-Client mit dem 'action'-Parameter
    const url = `${clientUrl}?action=${endpoint}`; 

    fetch(url)
        // ... (Verarbeitung der Antwort von client.php) ...
}</pre>

        <div class="note">
            <strong>Wichtiger Hinweis zu CORS:</strong> Für den Testbetrieb der JavaScript-Anwendung müssen Sie in <code>api.php</code> (oder im Apache/Nginx) den Header <code>header('Access-Control-Allow-Origin: *');</code> setzen, um CORS-Probleme zu vermeiden.
        </div>

    </div>
</body>
</html>
